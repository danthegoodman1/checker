// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: job_definitions.sql

package query

import (
	"context"
)

const deleteJobDefinition = `-- name: DeleteJobDefinition :exec
DELETE FROM job_definitions WHERE name = $1 AND version = $2
`

type DeleteJobDefinitionParams struct {
	Name    string
	Version string
}

func (q *Queries) DeleteJobDefinition(ctx context.Context, arg DeleteJobDefinitionParams) error {
	_, err := q.db.Exec(ctx, deleteJobDefinition, arg.Name, arg.Version)
	return err
}

const getJobDefinition = `-- name: GetJobDefinition :one
SELECT name, version, runtime_type, config, retry_policy, metadata, created_at, updated_at FROM job_definitions WHERE name = $1 AND version = $2
`

type GetJobDefinitionParams struct {
	Name    string
	Version string
}

func (q *Queries) GetJobDefinition(ctx context.Context, arg GetJobDefinitionParams) (JobDefinition, error) {
	row := q.db.QueryRow(ctx, getJobDefinition, arg.Name, arg.Version)
	var i JobDefinition
	err := row.Scan(
		&i.Name,
		&i.Version,
		&i.RuntimeType,
		&i.Config,
		&i.RetryPolicy,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJobDefinitions = `-- name: ListJobDefinitions :many
SELECT name, version, runtime_type, config, retry_policy, metadata, created_at, updated_at FROM job_definitions ORDER BY name, version
`

func (q *Queries) ListJobDefinitions(ctx context.Context) ([]JobDefinition, error) {
	rows, err := q.db.Query(ctx, listJobDefinitions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobDefinition
	for rows.Next() {
		var i JobDefinition
		if err := rows.Scan(
			&i.Name,
			&i.Version,
			&i.RuntimeType,
			&i.Config,
			&i.RetryPolicy,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertJobDefinition = `-- name: UpsertJobDefinition :exec
INSERT INTO job_definitions (name, version, runtime_type, config, retry_policy, metadata, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
ON CONFLICT (name, version) DO UPDATE SET
    runtime_type = EXCLUDED.runtime_type,
    config = EXCLUDED.config,
    retry_policy = EXCLUDED.retry_policy,
    metadata = EXCLUDED.metadata,
    updated_at = NOW()
`

type UpsertJobDefinitionParams struct {
	Name        string
	Version     string
	RuntimeType string
	Config      []byte
	RetryPolicy []byte
	Metadata    []byte
}

func (q *Queries) UpsertJobDefinition(ctx context.Context, arg UpsertJobDefinitionParams) error {
	_, err := q.db.Exec(ctx, upsertJobDefinition,
		arg.Name,
		arg.Version,
		arg.RuntimeType,
		arg.Config,
		arg.RetryPolicy,
		arg.Metadata,
	)
	return err
}
