// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: jobs.sql

package query

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getJob = `-- name: GetJob :one
SELECT id, definition_name, definition_version, state, env, params, result_exit_code, result_output, error, created_at, started_at, completed_at, checkpoint_count, last_checkpoint_at, retry_count, suspend_until, checkpoint_path, runtime_type, runtime_config, metadata FROM jobs WHERE id = $1
`

func (q *Queries) GetJob(ctx context.Context, id string) (Job, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.DefinitionName,
		&i.DefinitionVersion,
		&i.State,
		&i.Env,
		&i.Params,
		&i.ResultExitCode,
		&i.ResultOutput,
		&i.Error,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CheckpointCount,
		&i.LastCheckpointAt,
		&i.RetryCount,
		&i.SuspendUntil,
		&i.CheckpointPath,
		&i.RuntimeType,
		&i.RuntimeConfig,
		&i.Metadata,
	)
	return i, err
}

const getNonTerminalJobs = `-- name: GetNonTerminalJobs :many
SELECT id, definition_name, definition_version, state, env, params, result_exit_code, result_output, error, created_at, started_at, completed_at, checkpoint_count, last_checkpoint_at, retry_count, suspend_until, checkpoint_path, runtime_type, runtime_config, metadata FROM jobs WHERE state NOT IN ('completed', 'failed')
`

func (q *Queries) GetNonTerminalJobs(ctx context.Context) ([]Job, error) {
	rows, err := q.db.Query(ctx, getNonTerminalJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.DefinitionName,
			&i.DefinitionVersion,
			&i.State,
			&i.Env,
			&i.Params,
			&i.ResultExitCode,
			&i.ResultOutput,
			&i.Error,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CheckpointCount,
			&i.LastCheckpointAt,
			&i.RetryCount,
			&i.SuspendUntil,
			&i.CheckpointPath,
			&i.RuntimeType,
			&i.RuntimeConfig,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSuspendedJobsToWake = `-- name: GetSuspendedJobsToWake :many
SELECT id, definition_name, definition_version, state, env, params, result_exit_code, result_output, error, created_at, started_at, completed_at, checkpoint_count, last_checkpoint_at, retry_count, suspend_until, checkpoint_path, runtime_type, runtime_config, metadata FROM jobs
WHERE state = 'suspended' AND suspend_until IS NOT NULL AND suspend_until <= $1
ORDER BY suspend_until ASC
LIMIT $2
`

type GetSuspendedJobsToWakeParams struct {
	SuspendUntil sql.NullTime
	Limit        int32
}

func (q *Queries) GetSuspendedJobsToWake(ctx context.Context, arg GetSuspendedJobsToWakeParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, getSuspendedJobsToWake, arg.SuspendUntil, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.DefinitionName,
			&i.DefinitionVersion,
			&i.State,
			&i.Env,
			&i.Params,
			&i.ResultExitCode,
			&i.ResultOutput,
			&i.Error,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CheckpointCount,
			&i.LastCheckpointAt,
			&i.RetryCount,
			&i.SuspendUntil,
			&i.CheckpointPath,
			&i.RuntimeType,
			&i.RuntimeConfig,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertJob = `-- name: InsertJob :exec
INSERT INTO jobs (
    id, definition_name, definition_version, state, env, params,
    created_at, runtime_type, runtime_config, metadata
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type InsertJobParams struct {
	ID                string
	DefinitionName    string
	DefinitionVersion string
	State             JobState
	Env               []byte
	Params            []byte
	CreatedAt         time.Time
	RuntimeType       string
	RuntimeConfig     []byte
	Metadata          []byte
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) error {
	_, err := q.db.Exec(ctx, insertJob,
		arg.ID,
		arg.DefinitionName,
		arg.DefinitionVersion,
		arg.State,
		arg.Env,
		arg.Params,
		arg.CreatedAt,
		arg.RuntimeType,
		arg.RuntimeConfig,
		arg.Metadata,
	)
	return err
}

const listJobs = `-- name: ListJobs :many
SELECT id, definition_name, definition_version, state, env, params, result_exit_code, result_output, error, created_at, started_at, completed_at, checkpoint_count, last_checkpoint_at, retry_count, suspend_until, checkpoint_path, runtime_type, runtime_config, metadata FROM jobs
WHERE ($2::TIMESTAMPTZ IS NULL OR
       (created_at, id) < ($2::TIMESTAMPTZ, $3::TEXT))
ORDER BY created_at DESC, id DESC
LIMIT $1
`

type ListJobsParams struct {
	Limit           int32
	CursorCreatedAt sql.NullTime
	CursorID        sql.NullString
}

func (q *Queries) ListJobs(ctx context.Context, arg ListJobsParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobs, arg.Limit, arg.CursorCreatedAt, arg.CursorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.DefinitionName,
			&i.DefinitionVersion,
			&i.State,
			&i.Env,
			&i.Params,
			&i.ResultExitCode,
			&i.ResultOutput,
			&i.Error,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CheckpointCount,
			&i.LastCheckpointAt,
			&i.RetryCount,
			&i.SuspendUntil,
			&i.CheckpointPath,
			&i.RuntimeType,
			&i.RuntimeConfig,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobCheckpointed = `-- name: UpdateJobCheckpointed :exec
UPDATE jobs SET
    state = $2,
    checkpoint_count = checkpoint_count + 1,
    last_checkpoint_at = $3,
    suspend_until = $4,
    checkpoint_path = $5
WHERE id = $1
`

type UpdateJobCheckpointedParams struct {
	ID               string
	State            JobState
	LastCheckpointAt sql.NullTime
	SuspendUntil     sql.NullTime
	CheckpointPath   sql.NullString
}

func (q *Queries) UpdateJobCheckpointed(ctx context.Context, arg UpdateJobCheckpointedParams) error {
	_, err := q.db.Exec(ctx, updateJobCheckpointed,
		arg.ID,
		arg.State,
		arg.LastCheckpointAt,
		arg.SuspendUntil,
		arg.CheckpointPath,
	)
	return err
}

const updateJobCompleted = `-- name: UpdateJobCompleted :exec
UPDATE jobs SET
    state = $2,
    completed_at = $3,
    result_exit_code = $4,
    result_output = $5,
    error = $6
WHERE id = $1
`

type UpdateJobCompletedParams struct {
	ID             string
	State          JobState
	CompletedAt    sql.NullTime
	ResultExitCode pgtype.Int4
	ResultOutput   []byte
	Error          sql.NullString
}

func (q *Queries) UpdateJobCompleted(ctx context.Context, arg UpdateJobCompletedParams) error {
	_, err := q.db.Exec(ctx, updateJobCompleted,
		arg.ID,
		arg.State,
		arg.CompletedAt,
		arg.ResultExitCode,
		arg.ResultOutput,
		arg.Error,
	)
	return err
}

const updateJobRetryCount = `-- name: UpdateJobRetryCount :exec
UPDATE jobs SET retry_count = $2 WHERE id = $1
`

type UpdateJobRetryCountParams struct {
	ID         string
	RetryCount int32
}

func (q *Queries) UpdateJobRetryCount(ctx context.Context, arg UpdateJobRetryCountParams) error {
	_, err := q.db.Exec(ctx, updateJobRetryCount, arg.ID, arg.RetryCount)
	return err
}

const updateJobStarted = `-- name: UpdateJobStarted :exec
UPDATE jobs SET state = 'running', started_at = $2 WHERE id = $1
`

type UpdateJobStartedParams struct {
	ID        string
	StartedAt sql.NullTime
}

func (q *Queries) UpdateJobStarted(ctx context.Context, arg UpdateJobStartedParams) error {
	_, err := q.db.Exec(ctx, updateJobStarted, arg.ID, arg.StartedAt)
	return err
}

const updateJobState = `-- name: UpdateJobState :exec
UPDATE jobs SET state = $2 WHERE id = $1
`

type UpdateJobStateParams struct {
	ID    string
	State JobState
}

func (q *Queries) UpdateJobState(ctx context.Context, arg UpdateJobStateParams) error {
	_, err := q.db.Exec(ctx, updateJobState, arg.ID, arg.State)
	return err
}
